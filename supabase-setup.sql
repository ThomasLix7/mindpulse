-- Function to check if an extension exists
CREATE OR REPLACE FUNCTION public.check_extension_exists(extension_name text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  extension_exists boolean;
BEGIN
  SELECT EXISTS(
    SELECT 1 FROM pg_extension WHERE extname = extension_name
  ) INTO extension_exists;
  
  RETURN extension_exists;
END;
$$;

-- Wrapper function to create the pgvector extension (requires superuser)
CREATE OR REPLACE FUNCTION public.create_vector_extension()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  CREATE EXTENSION IF NOT EXISTS vector;
END;
$$;

-- Function to create the vector helper function
CREATE OR REPLACE FUNCTION public.create_check_extension_function()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  CREATE OR REPLACE FUNCTION public.check_extension_exists(extension_name text)
  RETURNS boolean
  LANGUAGE plpgsql
  SECURITY DEFINER
  AS $func$
  DECLARE
    extension_exists boolean;
  BEGIN
    SELECT EXISTS(
      SELECT 1 FROM pg_extension WHERE extname = extension_name
    ) INTO extension_exists;
    
    RETURN extension_exists;
  END;
  $func$;
END;
$$;

-- Function to create the ai_memories table
CREATE OR REPLACE FUNCTION public.create_ai_memories_table()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  CREATE TABLE IF NOT EXISTS public.ai_memories (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content text NOT NULL,
    embedding vector(768),
    metadata jsonb
  );
  
  -- Create index for vector similarity search
  CREATE INDEX IF NOT EXISTS ai_memories_embedding_idx 
  ON public.ai_memories 
  USING ivfflat (embedding vector_cosine_ops)
  WITH (lists = 100);
  
  -- Create index for session_id lookups
  CREATE INDEX IF NOT EXISTS ai_memories_session_id_idx 
  ON public.ai_memories ((metadata->>'sessionId'));
  
  -- Create index for user_id lookups
  CREATE INDEX IF NOT EXISTS ai_memories_user_id_idx 
  ON public.ai_memories ((metadata->>'userId'));
END;
$$;

-- Function to create the profiles table
CREATE OR REPLACE FUNCTION public.create_profiles_table()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Create the profiles table if it doesn't exist
  CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id),
    username TEXT,
    avatar_url TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
  );
  
  -- Create a trigger function to automatically create a profile for new users
  CREATE OR REPLACE FUNCTION public.handle_new_user()
  RETURNS TRIGGER
  LANGUAGE plpgsql
  SECURITY DEFINER
  AS $func$
  BEGIN
    INSERT INTO public.profiles (id)
    VALUES (NEW.id)
    ON CONFLICT (id) DO NOTHING;
    RETURN NEW;
  END;
  $func$;
  
  -- Create the trigger to call the function when a user is created
  DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
  CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
  
  -- Add indexes for profiles table
  CREATE INDEX IF NOT EXISTS profiles_username_idx ON public.profiles (username);
END;
$$;

-- Enable RLS on the ai_memories table
ALTER TABLE IF EXISTS public.ai_memories ENABLE ROW LEVEL SECURITY;

-- Create policy to allow authenticated users to insert their own memories
CREATE POLICY insert_own_memories 
ON public.ai_memories 
FOR INSERT 
TO authenticated 
WITH CHECK (
  (metadata->>'userId')::uuid = auth.uid()
);

-- Create policy to allow authenticated users to select only their own memories
CREATE POLICY select_own_memories 
ON public.ai_memories 
FOR SELECT 
TO authenticated 
USING (
  (metadata->>'userId')::uuid = auth.uid()
);

-- Create policy to allow anon to use session-based memories
CREATE POLICY anon_session_memories 
ON public.ai_memories 
FOR ALL 
TO anon 
USING (
  metadata->>'sessionId' IS NOT NULL
);

-- Grant necessary privileges to service_role and anon
GRANT ALL ON public.ai_memories TO service_role;
GRANT SELECT, INSERT ON public.ai_memories TO anon; 

-- Enable RLS on profiles table
ALTER TABLE IF EXISTS public.profiles ENABLE ROW LEVEL SECURITY;

-- Create policy for users to view their own profiles
CREATE POLICY view_own_profile
ON public.profiles
FOR SELECT
TO authenticated
USING (id = auth.uid());

-- Create policy for users to update their own profiles
CREATE POLICY update_own_profile
ON public.profiles
FOR UPDATE
TO authenticated
USING (id = auth.uid());

-- Grant necessary privileges on profiles table
GRANT ALL ON public.profiles TO service_role;
GRANT SELECT, UPDATE ON public.profiles TO authenticated; 